\chapter{Simulation}
\label{chapter:simulation}

\section{Modelling Circuits}
A circuit can be modelled as a set of components and a set of wires. The fields which define components and wires are shown in figures \ref{fig:component} and \ref{fig:wire} respectively. The only constraint placed on circuits is that no more than one wire may go into the same input port of the same component.

\begin{figure}[H]
\centering
\begin{itemize}
	\item The \textbf{number of inputs} the component has ($N$)
	\item The \textbf{number of outputs} the component has ($M$)
	\item An \textbf{evaluation function} which takes a list of $N$ truth values and returns a list  of $M$ truth values
\end{itemize}
\caption{Fields of a Component}
\label{fig:component}
\end{figure}

\begin{figure}[H]
\centering
\begin{itemize}
	\item The \textbf{source component} which  the wire is leaving from
	\item The \textbf{output port} of the source component
	\item The \textbf{target component} which the wire is going to
	\item The \textbf{input port} of the target component
	\item The current \textbf{truth value} of the wire 
\end{itemize}
\caption{Fields of a Wire}
\label{fig:wire}
\end{figure}

We say that component $X$ is \textit{wired} to component $Y$ if there exists a wire $w$ in the set of wires such that $w$'s source component is $X$ and $w$'s target component is $Y$.

We assume for now that each component has a constant propagation delay $\delta$, which is defined by the component's evaluation function. The background section~\ref{sec:circuits} states that a gate's propagation delay actually varies, and we will take that into consideration later in this chapter.

\subsection{2-Valued Simulation}
Logic circuits are physical implementations of Boolean functions. The domain of Boolean variables is $\{True, False\}$, so a natural simulation would use the same two truth values for the evaluation functions in our model. In other words, each wire has one of two values: \textit{True} or \textit{False}. 

We consider the problems with a 2-valued simulation in section~\ref{sec:2-valued} and fix them by using a 3-valued simulation in section~\ref{sec:3-valued}, but for now let us set the domain of truth values to be $\{True, False\}$.

\section{Event-Based Simulation}
GatePlay uses an event-based algorithm to simulate logic circuits. An event is a notification that a specific output of a component has changed. They are defined by a 4-tuple $(X, P, T, V)$ where:

\begin{itemize}
	\item \textbf{X} is the \textbf{source component} the event is propagating from
	\item \textbf{P} is the \textbf{output port} on the source component which has changed value
	\item \textbf{T} is the \textbf{event time} at which it is occurring
	\item \textbf{V} is the new \textbf{truth value} of the output port
\end{itemize}

Events are stored in a priority queue, and have priority equal to their event time. Lower times are more urgent. 

\subsection{Initial Components}
\label{subsec:initial}
The first events in a simulation run are generated by what I call \textit{Initial Components}. An initial component is defined as a component which takes no inputs. Some examples of initial components are described below:

\begin{itemize}
	\item \textbf{Constant Components} such as $ON$ and $OFF$ never change value, and so place their events in the queue just once when the circuit is initialised
	
	\item \textbf{Timed Components} such as $Blinker$s toggle their output at a set interval. The algorithm to implement this is non-trivial and discussed in chapter~\ref{chapter:implementation}
	
	\item \textbf{External Components} such as $Toggle$s add events based on user interaction. Since the stimulus to create an event comes from outside the simulator, it is a simple case of putting a method to create circuit events in the circuit's public API
\end{itemize}


\subsection{The Event Loop}
The heart of an event-based simulation is the event loop which processes all the events and generates new events. The stages of the event loop body are shown in figure~\ref{fig:eventloop}.

\begin{figure}[H]
\begin{enumerate}
	\item \textbf{Fetch} the next event to be processed from priority queue
	\item \textbf{Update} the value of the wires connected to the event port
	\item \textbf{Recalculate} the output of any gates whose inputs changed
	\item \textbf{Propagate} the change by creating new events for each changed output
\end{enumerate}
\caption{Event Loop Body}
\label{fig:eventloop}
\end{figure}

\subsection{Event Loop Example}
Consider the circuit shown in figure~\ref{fig:simple}. Let $X$'s current output be $False$, the event queue contain a single event $ev = (X, 1, t, True)$, and the current time be $t$.

\begin{figure}[H]
\centering
\begin{circuitikz} \draw
	(1,0) node[not port] (not1) {}
	(3,0) node[not port] (not2) {}
	(not1.out) -- node[above] {A} (not2.in);
	\draw (not1) node[left=-2pt] {X};
	\draw (not2) node[left=-2pt] {Y};
\end{circuitikz}
\caption{Two $NOT$ Gates}
\label{fig:simple}
\end{figure}

When the event loop body executes at simulated time $t$, the following actions occur:

\begin{enumerate}
	\item Pop $ev$ from the queue
	\item Update $A$ --- the wire coming from $X$ port $1$ --- to be valued $True$
	\item $A$ enters $Y$, so $Y$'s input has changed. Apply $Y$'s evaluation function to the new input, which returns $False$ (as $\lnot True = False$)
	\item Since $Y$'s output changed, add the following new event to the queue: $(Y, 1, t + \delta, False)$ where $\delta$ is $Y$'s propagation delay
\end{enumerate}

As the event loop repeats, changes propagate through a circuit.

\subsection{Culling}
\label{subsec:culling}
Events can sometimes be discarded without being processed by the entire event loop body. For example, events which set an output port to the value it already is do not change anything in the circuit and can be discarded during stage 2 of the event loop.

\subsection{Event Race Conditions}
Consider the circuit shown in figure~\ref{fig:racecondition}:
\begin{figure}[H]
\centering
\begin{circuitikz} \draw
	(1,0) node[and port] (and1) {}
	(and1.in 1) node[anchor=east]{False - A}
	(and1.in 2) node[anchor=east]{False - B}
	(and1.out) node[anchor=west]{C - False};
	 \draw (and1) node[left=12pt] {Z};
\end{circuitikz}
\caption{AND gate}
\label{fig:racecondition}
\end{figure}

Let there be two events in the event queue: $ev_1 = (X, 1, t, True)$ and $ev_2 = (Y, 1, t, True)$ where wire $A$ leaves $X$ port $1$, and wire $B$ leaves $Y$ port $1$.  In other words, A and B both become $True$ at simulated time $t$. Now consider what happens in the event loop at time $t$.

Suppose we handle $ev_1$ first: We set $A$ to $True$, $B$ is still thought to be $False$, and therefore we add the event $ev_3 = (Z, 1, t + \delta, False)$ to the queue (as $True \land False = False$).

Next we handle $ev_2$: $B$ is set to $True$ and $A$ is known to be $True$, so we add the event $ev_4 = (Z, 1, t + \delta, True)$ to the queue (as $True \land True = True$).

The queue now contains two events with different truth values occurring on $Z$ port $1$ at the same time. At simulated time $t + \delta$, if $ev_3$ is handled first it will be culled and the circuit will be simulated correctly. However if it is handled second then the output of $Z$ will be calculated as $False$, despite both its inputs being $True$! Since we are using a priority queue and both events have the same priority, there is no defined behaviour for which event will be handled first.

The solution is to do a first pass through all events happening at time $t$ and update the values of each of the affected wires. We look at $ev_1$ at set $A$ to $True$, and at $ev_2$ and set $B$ to $True$. Now if we process $ev_1$: $A$ and $B$ are already set to $True$ because of the first pass, and we calculate $Z$'s output to be $True$. Handling $ev_2$ will again yield $True$, and one of the duplicate events will be culled.

There is a further refinement implemented in GatePlay: when we do the initial pass through all events happening at time $t$ we maintain a set  of the affected components. In this example both events only affect $Z$, so the set will be $\{Z\}$ --- sets do not store duplicate values. We then re-calculate the output of each component in the set and add the event to the queue. In this case, we will only calculate and add $(Z, 1, t + \delta, True)$ once.

\subsection{Efficiency}
The speed of an event-based simulation is proportional to the number of events being generated and processed. For this reason, reducing the time spend processing events through Culling (see section~\ref{subsec:culling}) is critically important.

Also note that (if sensible data structures are used) event-based simulations still perform well in circuits with a very large number of components and connections, so long as relatively few events are occurring. An efficient simulation is not necessary for GatePlay as the UI only allows users to build modest-sized circuits, but it is good to implement an efficient simulator regardless in case the UI is ever changed.

\section{Limitations of 2-Valued Simulations}
\label{sec:2-valued}

\subsection{Initialisation Values}
\label{subsec:2-valued initialisation}
In a 2-valued simulation all wires must be either $True$ or $False$ valued. It is necessary to initialise the wire values before the circuit begins, but what is a sensible default? Suppose we initialise all wires to $False$, and consider the circuit in figure~\ref{fig:initialisation}:

\begin{figure}[H]
\centering
\begin{circuitikz} \draw
	(1,0) node[not port] (not1) {}
	(not1.in) node[anchor=east] {False - A}
 	(not1.out) node[anchor=west] {B - False};
\end{circuitikz}
\caption{An inconsistently initialised $NOT$ Gate}
\label{fig:initialisation}
\end{figure}

To have both $A$ and $B$ both be initialised to be $False$ is inconsistent with the logic of a $NOT$ gate. The same would be true if wires were initialised to $True$. One option would be to add a boolean flag to wires indicating that no event has reach them yet and leave them uninitialised. GatePlay, however, fixes the problem by using a 3-valued simulation (section~\ref{sec:3-valued}).


\subsection{Propagation Delay Uncertainty}
\label{subsec:2-valued uncertainty}
As discussed in section~\ref{sec:circuits}, the \textit{Propagation Delay} of a component is the time it takes from its inputs being stable and valid to its outputs becoming stable and valid\cite{Wikipedia: Propagation Delay}. 

Previously we have assumed that this delay is constant for a given component, but in reality the precise delay varies based on temperature, voltage, and output capacitance\cite{Wikipedia: Propagation Delay}. Our model of logic circuits does not consider these factors and therefore cannot make an informed estimation of the true delay for each pass through a component.

We assume that the propagation delay is never less than $\delta_{min}$ and never greater than $\delta_{max}$. $\delta_{min}$ and $\delta_{max}$ can be different for different types of components.

\begin{figure}[H]
\centering
\begin{circuitikz} \draw
	(1,0) node[not port] (not1) {}
	(not1.in) node[anchor=east] {A}
 	(not1.out) node[anchor=west] {B};
\end{circuitikz}
\caption{A $NOT$ Gate}
\label{fig:2-valued-circuit}
\end{figure}

\begin{figure}[H]
\centering
	\begin{tikzpicture}[domain=0:4, xscale=1.5, yscale=0.75]
		\node[draw] at (-1,0.5) {A}; 
		\node[draw] at (-1,-1.5) {B}; 
   		\draw [thick] (0,1) node[left] {True} -- (1,1);
    	\draw [thick, dashed] (1,1) -- (1,0);
    	\draw [thick] (1,0) -- (4,0) node[right] {False};
    	\draw [thick] (0,-2) node[left] {False} -- (2,-2);
    	\draw [pattern=north west lines] (2,-2) rectangle (2.5,-1);
    	\draw [thick] (2.5,-1) -- (4,-1) node[right] {True};
    	\draw [thick,->] (-1,-5) -- (5,-5) node[right] {Time}; 
    	\draw [<->] (1,-2.5) -- (2,-2.5) 
			node [pos=0.5,anchor=north] {$\delta_{min}$};
		\draw [<->]	(1,-3.5) -- (2.5,-3.5) 
			node [pos=0.5,anchor=north] {$\delta_{max}$};
	\end{tikzpicture}
	\caption{Trace of a $NOT$ gate's input and output}
	\label{fig:2-valued-trace}
\end{figure}

Consider the circuit shown in figure~\ref{fig:2-valued-circuit}. If we flip A's value from $True$ to $False$ the trace of the truth values through time is shown in figure~\ref{fig:2-valued-trace}. $B$'s transition from $False$ to $True$ can happen at any point in hatched region based on the aforementioned factors. A 2-valued simulator at this level of detail can therefore only assume that the transition happens at a random time. In other words, the precise propagation delay for each pass through a component is randomly sampled from the interval $[\delta_{min}, \delta_{max}]$.

Each simulation of a circuit will likely have different propagation delays which can potentially change the output of a circuit altogether. If one run of this simulation yields a given result there is no guarantee that \textit{all} runs would yield the same result. I felt this was not desirable behaviour for a simulator. In the next section we introduce a simulator which models the uncertainly of components without introducing non-determinism in the simulation itself.

\section{3-Valued Simulation}
\label{sec:3-valued}
The way I decided to overcome the problems of 2-valued simulation described in section~\ref{sec:2-valued} was to instead use a 3-valued simulation. A wire has one of three values: $True$, $False$, or $Unknown$. A wire that is $Unknown$ is ``in reality'' either $True$ or $False$, but the simulation does not know which.

\subsection{Initialisation Values}
In a 3-valued simulation all wires can be initialised to $Unknown$ without the problem of inconsistency for 2-valued simulations discussed in section~\ref{subsec:2-valued initialisation}.

\subsection{Propagation Delay Uncertainty}
\label{subsec:3-valued uncertainty}
The 2-valued simulation was unable to model the uncertainty of component delay without making the result of each simulation run non-deterministic, as discussed in section~\ref{subsec:2-valued uncertainty}.

Suppose we have a component $X$ whose inputs are changing at time $t$. In the 2-valued simulation we would consider the outputs changing at time $t + \delta$ where $\delta$ is randomly sampled from the interval $[\delta_{min}, \delta_{max}]$. 

However in the 3-valued simulation we can consider the outputs of $X$ to be changing twice. At time $\delta_{min}$ they becoming $Unknown$, and then at time $\delta_{max}$ they settle on a stable value. 

By considering the output $Unknown$ for the duration of the delay uncertainty we have still modelled the uncertainty in the actual components, but without introducing uncertainty to our simulation. In other words, should a circuit yield a certain value in our simulation we know that it will yield the same value for \textit{all} possible combinations of gate delays.

Evaluation functions must also be augmented to accept $Unknown$ as in input, and potentially produce $Unknown$ as an output. For example, we define $True \land Unknown = Unknown$, $Unknown \land Unknown = Unknown$, and $False \land Unknown = False$.

\subsection{Event Suppression}
A bug was introduced in the simulator in section~\ref{subsec:3-valued uncertainty}. Consider the circuit shown in figure~\ref{fig:suppression}. Let $\delta_{min}$ and $\delta_{max}$ be the minimum and maximum gate delays respectively. $A$, $B$, and $C$ are all $False$.

\begin{figure}[H]
\centering
\begin{circuitikz} \draw
	(1,0) node[and port] (and1) {}
	(and1.in 1) node[anchor=east] {False - A}
	(and1.in 2) node[anchor=east] {False - B}
 	(and1.out) node[anchor=west] {C - False};
 	\draw (and1) node[left=12pt] {X};
\end{circuitikz}
\caption{An $AND$ Gate}
\label{fig:suppression}
\end{figure}

Let circuit event $e_1$ set $A$ to $True$ at time $t$, and event $e_2$ set $B$ to $True$ at time $t + 1$. It is now simulated time $t$. Using the algorithm thus far described we will handle $e_1$ and the following two events will be added to the queue: $e_3 = (X, 1, t + \delta_{min}, Unknown)$, $e_4 = (X, 1, t + \delta_{max}, False)$. Next, handling $e_2$ we will add the following events to the queue: $e_5 = (X, 1, t + 1 + \delta_{min}, Unknown)$, $e_6 = (X, 1, t + 1 + \delta_{max}, True)$.

The bug arises at simulated time $t + \delta_{max}$ when we handle $e_4$. At that time $C$ is set to $Unknown$ and we will set it to $False$. However this is incorrect behaviour as $e_2$ means that $C$ should be uncertain until $e_6$ is handled at time $t + 1 + \delta_{max}$.

In other words, the output of X is uncertain for two distinct reasons. $e_1$ causes $C$ to be uncertain in the interval $[t + \delta_{min}, t + \delta_{max})$, and $e_2$ makes $C$ uncertain in the interval $[t + 1 +  \delta_{min}, t + 1 + \delta_{max})$.

The simulator therefore must keep track of the intervals a wire is uncertain for, and \textit{suppress} any events which try to set it to a certain value in any of those intervals. In this example $e_4$ must be suppressed.