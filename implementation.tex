\chapter{Implementation}
\label{chapter:implementation}

GatePlay is implemented in the HTML/CSS/JavaScript stack. A brief overview of what HTML, CSS, and JavaScript are is provided in section~\ref{chapter:background}. This chapter will go through the main JavaScript files in the project and the relationships between them.

Some of the JavaScript files are not my own work, but open-source libraries. Re-using others' code lets me focus on implementing the parts unique to GatePlay and avoid writing boilerplate code\footnote{http://en.wikipedia.org/wiki/Boilerplate\_code}.

The implementation is split in to two main, independent parts: the workbench (section~\ref{section:workbench}) and the simulator (section~\ref{section:simulator}).

\section{Getting Started}
GatePlay is made up of many JavaScript files, but when its URL is visited the only file downloaded is the main HTML file: \textit{index.html}. The index must then direct the user's browser to download the additional files needed to run GatePlay.

JavaScript files are loaded into the browser using HTML Script tags, in the order the Script tags are written (see figure~\ref{fig:scripttags}). JavaScript scripts may use methods or variables defined in other scripts provided that those scripts have already been loaded and run.

That means that if $component.js$ and $componentview.js$ are JavaScript scripts, and $componentview.js$ depends on $component.js$, then $component.js$'s Script tag must appear first or the website will crash.

\begin{figure}[H]
\begin{lstlisting}[language=html]
<!-- componentview depends on component -->
<!-- Therefore we ensure component is loaded first -->
<script type="text/javascript" src=".../component.js"></script>
<script type="text/javascript" src=".../componentview.js"></script>
\end{lstlisting}
\caption{Example use of Script tags}
\label{fig:scripttags}
\end{figure}

\subsection{Require.js}
It is time consuming for a human to find and type out a correct ordering for the Script tags, and it would need to be updated every time a file as added or removed, or sometimes if a file were modified.

Require.js is a JavaScript file loader which does automatically loads files in a correct order. Each JavaScript file declares each of its direct dependencies, and Require.js will ensure they are all loaded correctly when the website loads.

\begin{figure}[H]
\begin{lstlisting}[language=JavaScript]
// componentview.js

require([
	// Declare the path of each file we require	
	"canvas/model/component"
], function(Component) {
	// Each included file is run, and we can give a name to whatever it returns if desired
	var myComponent = new Component();
	...
});
\end{lstlisting}
\caption{An example file which uses Require.js}
\end{figure}

\section{The Workbench}
\label{section:workbench}
GatePlay's workbench is where we create and view circuits. I used the model-view-controller\footnote{http://en.wikipedia.org/wiki/Model-view-controller} design pattern to simply development. MVC programs are split in to three type of component:

\begin{itemize}
	\item \textbf{Models} which store some part of the state of the application
	\item \textbf{Views} which display a representation of one of the models to the user
	\item \textbf{Controllers} which process user input, and updates the appropriate models.
\end{itemize}

The interactions between the components can be seen in figure~\ref{fig:mvc}. By separating out the concerns of the program it becomes possible to, for example, add new views for your models without needing to change the models or controllers themselves.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{mvc.png}
	\caption{Interaction of MVC Components, from Wikipedia}
	\label{fig:mvc}
\end{figure}

\subsection{MVC with Backbone.js}
Backbone.js\footnote{http://backbonejs.org} is a JavaScript library to reduce the amount of boilerplate code in developing MVC JavaScript applications by providing predefined notions of models, views, and controllers.

\subsection{Models}
I first created the models behind the workbench. The top-level model is a \textit{Circuit} model which contains a set of \textit{Component} models and a set of \textit{Wire} models.

The part of the Component model definition is shown in figure~\ref{fig:componentmodel}. The actual model contains some additional helper methods, but they do not add any new state to the model and are not shown. Each Component is given a unique identifier (id), an (x, y) position on the workbench, a width, and input and output counts. The \textit{isValid} flag is set to False if this component is ever over another component (which the Circuit disallows) so it can be drawn in a different colour.

Notice that the height of a Component is a function of its input and output counts.

\begin{figure}
\begin{lstlisting}[language=JavaScript]
var Component = Backbone.Model.extend({
	defaults: function() {
    	return {
        	id: nextId++,
            x: 0,
            y: 0,
            width: 7,
            inputCount: 2,
            outputCount: 1,
            isValid: true,
            activeInputIndex: -1,
            activeOutputIndex: -1
        }
    },

    getHeight: function() {
        return Math.max(this.get("inputCount"), this.get("outputCount")) * 2 + 1;
    }
});
\end{lstlisting}
\caption{Definition of a Component model}
\label{fig:componentmodel}
\end{figure}

Next I created the Wire model (figure~\ref{fig:wiremodel}). The Wire model is very close to the definition of a wire we used in the simulator, except we additionally store a list of \textit{fixed points}. Fixed points are points through which the wire passes on its way from the source component to the target component.

\begin{figure}
\begin{lstlisting}[language=JavaScript]
var Wire = Backbone.Model.extend({
	defaults: function() {
    	return {
        	id: nextWireId++,
        	sourceId: -1,
        	sourcePort: -1,
       	 	targetId: -1,
        	targetPort: -1,
        	fixedPoints: [],
        	truthValue: TruthValue.UNKNOWN
    	}
	},
})
\end{lstlisting}
caption{Definition of a Wire model}
\label{fig:wiremodel}
\end{figure}

With the Component and Wire models we can create a Circuit model. I will not include the Circuit model code listing as it is relatively long and simple, but rather describe how it works. 

As in the simulator, a Circuit on the workbench contains a set of Components and a Set of Wires. The workbench Circuit also has a set width and height which all components and wires are contained in.

In GatePlay components are not permitted to overlap each other, and it is the Circuit model's responsibility to enforce this. Recall that the Circuit has a given width and height, and each component has a position, width, and height. The Circuit maintains a 2D array where each cell is a point on the workbench, containing the identifier of the component at that position (or an empty flag if no component). When adding a component to the circuit, it checks that no component already occupies those cells.

\subsection{Views}
To display circuits to the user we need an element on the web page to draw graphics. An HTML Canvas element is a blank slate on which we can draw shapes and images --- exactly the functionality required for GatePlay --- and is what I used.

\subsubsection{Fabric.js}
From the user's perspective the workbench is going to contain a collection of objects (components), each of which can be selected and moved. An HTML Canvas is essentially a flat array of pixels, however, and does have any kind of concept of objects on the canvas.

Fabric.js is an canvas framework which wraps HTML Canvas elements with an object model, allowing GatePlay to interact at the level of objects being added to, modified, and removed from the canvas.

As an example, consider the user moving a component from one position on the workbench to another. With an HTML Canvas I would need to re-calculate and re-draw the background over the component, and then re-draw the component at its new location. Using Fabric.js it is a simple library call to move the component.

Fabric.js greatly reduces the amount of boilerplate code needed to interact with HTML canvases, and it used in GatePlay.

Initially GatePlay used a different canvas framework called KineticJS, but due to difficulties getting features like snap-to-grid working I switched to Fabric.js.

\subsubsection{ComponentView}
Now that we


After creating the models needed for workbench circuits I created views to display them to the user. 

\begin{figure}
\begin{lstlisting}[language=JavaScript]
Backbone.View.extend({
    initialize: function(options) {
        // When the model is changed, update the view
        this.model.on("change:fixedPoints", this.render, this);
        this.model.on("change:truthValue", this._setWireColor, this);
    },

    render : function() {
        var model = this.model;
		
		// Using the model data we can now draw wires on the canvas
    },

    _setWireColor: function() {
        var truthValue = this.model.get("truthValue");
        
        // We can now re-render the wire with the new colour
    }
});
\end{lstlisting}
caption{Definition of a Wire view}
\label{fig:wireview}
\end{figure}

\subsection{Editing Mode}

\subsection{Running Mode}

\section{The Simulator}
\label{section:simulator}
The implementation of GatePlay's simulator is a relatively straightforward implementation of the algorithms and ideas explained in section~\ref{chapter:simulation}. The following six classes fully implement the simulator:

\begin{itemize}
	\item \textbf{truthvalue.js} defines constants $True$, $False$, and $Unknown$
	\item \textbf{component.js} defines a Component by its input count, output count, and evaluation function
	\item \textbf{wire.js} defines a Wire by its input component and port, output component and port, and truth value
	\item \textbf{circuitevent.js} defines a CircuitEvent by component, port, timestamp, and value
	\item \textbf{functions.js} contains definitions of all the Evaluation Functions available to the simulator 
	\item \textbf{circuit.js} is the only class which need be visible from outside the simulator. It has an interface to add components and wires. Circuit.js implements the algorithm for the event loop. 
\end{itemize}

\subsection{Blinker Events}
Recall section~\ref{subsec:initial} that $Blinker$ components toggle their output value at a set interval. Each $Blinker$ has its own, potentially unique, interval.

To implement this, a $Blinker$ component's evaluation function (shown in figure~\ref{fig:blinkereval} determines it truth value backed on the simulation clock.

\begin{figure}
\begin{lstlisting}[language=JavaScript]
Blinker.prototype._doEvaluate = function(argList, clock) {
    var period = Math.floor(clock / this._interval);
    var parity = period % 2;
    if (parity === 0) {
        return [TruthValue.TRUE];
    } else {
        return [TruthValue.FALSE];
    }
};
\end{lstlisting}
\caption{Implementation of $Blinker$'s evaluation function}
\label{fig:blinkereval}
\end{figure}

However a $Blinker$ will never be processed by the event loop, as no events will ever affect a $Blinker$ (it has no inputs). Therefore we need to handle $Blinker$s differently.

The solution implemented in GatePlay is to add a new circuit event for every $Blinker$, \textit{every} clock tick. For a $Blinker$ with interval $2$, we would add $True$ events at time $0$ and $1$, $False$ events at time $2$ and $3$, and so on. We rely on culling to eliminate the replicated events.

The algorithm described above if very easy to implement, but clearly inefficient if there were a large number of $Blinker$s. A better algorithm where we only add one circuit event per $Blinker$, per interval is outlined in figure~\ref{fig:blinkerqueue}. 

\begin{figure}
\begin{lstlisting}[language=JavaScript]
function tick() {
	// For each event which is happening at this time
	while (this._blinkerEventQueue.peek().time <= this._clock) {
		var event = this._blinkerEventQueue.pop();
		this._addEvent(event);
		
		var blinker = this.getComponent(event.sourceId);
		var nextTime = event.eventTime + blinker.get("interval");
		var nextValue = blinker.evaluate([], nextTime);
		var nextEvent = new CircuitEvent(nextTime, event.sourceId, event.sourcePort, nextValue);
	}
	
	// Event loop goes here
}
\end{lstlisting}
\caption{}
\label{fig:blinkerqueue}
\end{figure}

Note that the \textit{blinkerEventQueue} is just a subset of the main event queue, and we could actually put this algorithm directly in the event loop. However doing so would couple our implementation of the general event queue with that of a specific type of component and not be good software engineering practice.

\section{Drag-and-drop}
One of the requirements of GatePlay was that it be easy to use, and the drag-and-drop nature of the interface is an important part of that. Implementing drag-and-drop is can be split in to three main sub problems:

\begin{enumerate}
	\item Drawing the components in the left-bar
	\item Allow dragging components from the left side-bar
	\item Adding components to the workbench where they dropped
\end{enumerate}

We first create an HTML Image element for each component on the left-bar. The matter of creating images for each component is handled by the  \textit{createThumbnail} function. \textit{createThumbnail} creates a temporary canvas for each component and renders the component on it. This canvas can be converted to an image file by Fabric.js.

jQueryUI\footnote{http://http://jqueryui.com/} is a JavaScript library to ease the creation of interactive web applications like GatePlay. jQueryUI supports \textit{Draggable} and \textit{Droppable} interactions, which implement exactly what we want. The components in the left-bar are marked as Draggable and the main workbench is marked as Droppable, meaning components can now be dragged from the left-bar to the workbench.

To actually add the components to the workbench it is a matter of handling jQueryUI's \textit{drop} event.

\section{Tying GatePlay Together}
The implementation discussed so far has multiple distinct parts which have no knowledge of each other: the workbench, the simulator, and droppable interactions. We create a new class \textit{Application} which ties the pieces together as shown in figure~\ref{fig:application}

\begin{figure}[p]
    \centering
    \includegraphics[width=\textwidth]{application.png}
    \caption{Information flow in GatePlay}
    \label{fig:application}
\end{figure}


\subsection{application.js}
